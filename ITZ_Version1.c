#pragma config(Sensor, in1,    Left_Arm,       sensorPotentiometer)
#pragma config(Sensor, in2,    Right_Arm,      sensorPotentiometer)
#pragma config(Sensor, in3,    FouBar,         sensorPotentiometer)
#pragma config(Sensor, dgtl9,  drive_LeftSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, drive_RightSensor, sensorQuadEncoder)
#pragma config(Motor,  port2,           drive_Right,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift_Left,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           fourBar_Left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           fourBar_Right, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift_Right,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           drive_Left,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard               !!//

//---------------------------------------------------------------------------//
/*                                                                           /
/        Description: Competition template for VEX EDR                      /
/                                                                           /
/---------------------------------------------------------------------------*/
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#define drivethreshhold 10
double drivelimit= 127;

//static float  pidRequestedValue;
//---------------------------------------------------------------------------//
/*                          Pre-Autonomous Functions                         /
/                                                                           /
/  You may want to perform some actions before the competition starts.      /
/  Do them in the following function.  You must return from this function   /
/  or the autonomous and usercontrol tasks will not be started.  This       /
/  function is only called once after the cortex has been powered on and    /
/  not every time that the robot is disabled.                               /
/---------------------------------------------------------------------------/



/-----------------------------------------------------------------------------/
/                                                                             /
/  main task                                                                  /
/                                                                             /
/-----------------------------------------------------------------------------*/
int countx = 0; //counter for function at line 199
void stack (int coneNumber){

}

void drive_Forward(int power) {
	motor[drive_Left]= power;
	motor[drive_Right] =power;
}

void turn_Left(int power) {
	motor[drive_Left]= power;
	motor[drive_Right] =-power;
}

void turn_Right(int power) {
	motor[drive_Left]= -power;
	motor[drive_Right] = power;
}

void drive_Backward(int power) {
	motor[drive_Left]= -power;
	motor[drive_Right] =-power;
}

void arm_Up (int power) {
	motor[lift_Left] =power;
	motor[lift_Right] =power;
}

void arm_Down (int power) {
	motor[lift_Left] =-power;
	motor[lift_Right] =-power;
}

void claw_Open (int power) {
	motor[claw] =power;
}

void claw_Close (int power) {
	motor[claw] =-power;
}

void mogo_In (int power) {
	motor[mogo] =-power;
}

void mogo_Out (int power) {
	motor[mogo] =power;
}

void fourBar_Forward (int power) {
	motor[fourBar_Left] =power;
	motor[fourBar_Right] = power;
}

void fourBar_Backwards (int power) {
	motor[fourBar_Left] =-power;
	motor[fourBar_Right] = -power;
}

#define average ((SensorValue[drive_LeftSensor]+SensorValue[drive_RightSensor])/2)
void auton_DriveForward(int degrees){

	while (average < degrees){

		drive_Forward(127);
	}
	drive_Forward(0);
	SensorValue[drive_LeftSensor] = 0;
	SensorValue[drive_RightSensor] = 0;

}

void auton_MogoOut(int degrees){
	while (SensorValue [mogo] < degrees){		//Need to check the encoddr value
		mogo_Out(127);
	}
	mogo_Out(0);
	SensorValue[mogo] = 0;
}

void auton_MogoIn( int degrees){
	while (SensorValue [mogo] > -degrees){		//Need to check the encoder value
		mogo_In(127);
	}
	mogo_In(0);
	SensorValue[mogo] = 0;
}
void auton_TurnRight( int rotations){
	while (SensorValue [drive_Left] < rotations){
		turn_Right(127); // Test this, it may be the other way around
	}
	turn_Right(0);
	SensorValue[drive_LeftSensor] = 0;
}
void auton_TurnLeft( int rotations){
	while (SensorValue [drive_RightSensor] < rotations){
		turn_Left(127); // Test this, it may be the other way around (it is, same with lift)
	}
	turn_Left(0);
	SensorValue[drive_RightSensor] = 0;
}
void auton_DriveBackwards(int degrees){

	while (average > degrees){
		drive_Backward(127);
	}
	drive_Backward(0);
	SensorValue[drive_LeftSensor] =0;
	SensorValue[drive_RightSensor] =0;
}
void resetSensors(){
	SensorValue[drive_Left] = 0;
	SensorValue[drive_Right] = 0;

}
task noTipPlease()
{
	while(SensorValue[Left_Arm] > 20){
		drivelimit = 90;

}
}
task pidController()
{
	float  pidSensorCurrentValue;
	float  pidError;
	float  pidArm;

	while( true )
	{
		double pid_Kp;
		if(8>=abs(SensorValue[FouBar]-31)>3){
			pid_Kp=0.1
	}
	else if(20>=abs(SensorValue[FouBar]-31)>8){
			pid_Kp=0.2
	}
	else if(abs(SensorValue[FouBar]-31)>20){
			pid_Kp=0.5
	}
	else if(3>abs(SensorValue[FouBar]-31)){
		pid_Kp=0;
}
		// Read the sensor value and scale
		pidSensorCurrentValue = SensorValue[FouBar];

		// calculate error
		pidError =  31 - pidSensorCurrentValue;
		pidArm = (pid_Kp * pidError);

		// limit drive
		if( pidArm > 127 )
			pidArm = 127;
		if( pidArm < (-127) )
			pidArm = (-127);

		// send to motor
		motor[fourBar_Left] = motor[fourBar_Right] = pidArm;

		// Don't hog cpu
		wait1Msec( 25 );
	}
}
void stack_ArmUp (int rotations){
	while (SensorValue [lift_Left] < rotations){
		arm_Up(127); // Test this, it may be the other way around (it is, same with lift)
	}
	arm_Up(0);
	SensorValue[lift_Left] = 0;

}

void testFunction(int rotations){
// if this function is called the lift raises according to a value in an array.
//everytime the button is pressed a counter variable is incremented
// the counter variable will index the array to determine certain height raised

	int heights[15];
		heights[1] = 0;
		heights[2] =20;
		heights[3] =30;
		heights[4] =40;
		heights[5] =50;
		heights[6] = 60;
		heights[7] = 70;
		heights[8] =80;
		heights[9] =90;
		heights[10] =100;
		heights[11] =110;
		heights[12] = 120;
		heights[13] =130;
//figure out the predetermined heights

while(SensorValue[Lift_Left] <heights[countx]){
arm_Down(127);
}
arm_Down(0);
wait1Msec(25);

//Manual control to allign the cone needs to somehow be implemented
claw_Open(127);
fourBar_Backwards(127);

wait10Msec(35);
claw_Open(0);
fourBar_Backwards(0);
motor [lift_Left] = 0; //resets the lift back down
countx++;//Not sure if this is what you want but I got down the basic logic
}
void pre_auton()
{
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//---------------------------------------------------------------------------//
/*                                                                           /
/                              Autonomous Task                              /
/                                                                           /
/  This task is used to control your robot during the autonomous phase of   /
/  a VEX Competition.                                                       /
/                                                                           /
/  You must modify the code to add your own robot specific commands here.   /
/---------------------------------------------------------------------------*/

task autonomous()
{/*AutonSkills
	fourBar_Forward(127);
	wait10Msec(15);
	fourBar_Forward(0);
	arm_Down(127);
	wait10Msec(150)
	arm_Down(0);

	auton_DriveForward(300);
	claw_Close(127)
	wait10Msec(60);
	claw_Close(0);
	auton_DriveBackwards(50);
	auton_TurnLeft(23);
	mogo_In(127);
	wait10Msec(115);
	mogo_In(0);
	auton_DriveForward(688);
	fourBar_Forward(127);
	wait10Msec(180);
	claw_Open(127);
	arm_Up(127);
	wait10Msec(170);
	claw_Open(0);
	arm_Up(0);
	auton_TurnLeft(41);
	auton_DriveForward(430);
	mogo_Out(127);
	wait10Msec(150);
	mogo_Out(0);
	auton_TurnLeft(563);
	auton_DriveForward(1280);
	mogo_In(127);
	wait10Msec(150);
	mogo_In(0);
	drive_Backward(127);
	wait10Msec(190);
	drive_Backward(0);
	auton_TurnLeft(450);
	mogo_In(127);
	wait10Msec(150);
	mogo_In(0);
	auton_DriveForward(1400);
	mogo_Out(127);
	wait10Msec(150);
	mogo_Out(0);
	auton_TurnRight(563);
	auton_DriveForward(1450);
	mogo_In(127);
	wait10Msec(150);
	mogo_In(0);
	auton_DriveBackwards(200);

	*/
	/*Auton Numero Uno
	resetSensors();
	//
	arm_Down(127);
	wait10Msec(115);
	arm_Down(0);
	//
	fourBar_Backwards(127);
	wait10Msec(15);
	fourBar_Backwards(0);
	//
	mogo_In(127);
	wait10Msec(115);
	mogo_In(0);
	//
	auton_DriveForward(1318);
	resetSensors();
	//
	mogo_Out(127);
	wait10Msec(115);
	mogo_Out(0);
	//
	claw_Close(127);
	wait10Msec(60);
	claw_Close(0);
	//
	auton_DriveBackwards(1250);
	resetSensors();
	//
	auton_TurnLeft(1620);
	resetSensors();
	//
	mogo_In(127);
	wait10Msec(115);
	mogo_In(0);
	//
	auton_DriveBackwards(196);
	resetSensors();
	*/
	resetSensors();
	claw_Close(45);

	arm_Down(127);
	wait10Msec(150);
	arm_Down(0);
	fourBar_Forward(90);
	wait10Msec(58);
	fourBar_Forward(0);
	auton_DriveForward(87);
	wait10Msec(55);
	claw_Close(0);
	claw_Open(100);
	wait10Msec(160);
	claw_Open(0);
	auton_DriveBackwards(15);

	auton_TurnLeft(83);
	mogo_In(127);
	wait10Msec(115);
	mogo_In(0);
	auton_DriveForward(688);
	mogo_Out(127);
	wait10Msec(150);
	mogo_Out(0);
	auton_TurnLeft(563);
	auton_DriveForward(1280);
	mogo_In(127);
	wait10Msec(150);
	mogo_In(0);
	drive_Backward(127);
	wait10Msec(190);
	drive_Backward(0);
//Blocking Auton
	//drive_Forward(127);







	/*claw_Close(127);
	wait10Msec(100);
	claw_Close(80);
	arm_Down(127);
	wait10Msec(150);
	arm_Down(0);
	drive_Forward(127);
	wait10Msec(150);
	drive_Forward(0);
	arm_Up(127);
	wait10Msec(100);
	arm_Up(0);
	claw_Open(127);
	wait10Msec(250);
	claw_Open(0);

	resetSensors();
	*/
	//Cleared the sensor values

	//Stop the mobile goal intake
	/*
	/* Auton Two
	auton_MogoOut(510);
	auton_DriveForward(1380);
	auton_MogoIn(-510);
	auton_TurnLeft(2228);
	auton_DriveForward(1718);
	auton_MogoOut(510);
	auton_DriveBackwards(690);

	*//*
	arm_Down(127);
	wait10Msec(50);
	arm_Down(0);
	mogo_In(127);
	wait10Msec(115);
	mogo_In(0);
	drive_Forward(127);
	wait10Msec(230);
	drive_Forward(0);
	mogo_Out(127);
	wait10Msec(155);
	mogo_Out(0);
	fourBar_Backwards(127);
	wait10Msec(15);
	fourBar_Backwards(0);
	claw_Open(127);
	wait10Msec(115);
	claw_Open(0);
	mogo_In(127);
	wait10Msec(125);
	mogo_In(0);
	drive_Backward(127);
	wait10Msec(90);
	drive_Backward(0);
	/*
	drive_Backward(127);
	wait10Msec(255);
	drive_Backward(0);
	turn_Left(127);
	wait10Msec(130)
	turn_Left(0);

	drive_Forward(127);
	wait10Msec(220);

	drive_Forward(0);
	mogo_In(127);
	wait10Msec(125);
	mogo_In(0);
	drive_Backward(127);
	wait10Msec(300);
	drive_Backward(0);*/

}
// ..........................................................................
// Insert user code here.
// ..........................................................................

// Remove this function call once you have "real" code.


//---------------------------------------------------------------------------//
/*                                                                           /
/                              User Control Task                            /
/                                                                           /
/  This task is used to control your robot during the user control phase of /
/  a VEX Competition.                                                       /
/                                                                           /
/  You must modify the code to add your own robot specific commands here.   /
/---------------------------------------------------------------------------*/

task usercontrol()
{
	//startTask(noTipPlease);
	while(true) {
	if(vexRT[Btn6D]) {   //Claw stuffs
		arm_Down(127);
		} else if(vexRT[Btn6U]) {
		arm_Up(127);
		}
		else{
		arm_Down(0);
		}/*
		if(vexRT[Btn6DXmtr2]){
			mogo_In(127);
		}
		else if(vexRT[Btn6UXmtr2]){
			mogo_Out(127);
		}
		else{
			mogo_In(0);
		}*/

		if(vexRT[Btn7L]){
			claw_close(127);
		}
		else if(vexRT[Btn7D]){
			claw_Close(-127);
		}
		else{
			claw_Close(20);
		}

		/*
		if(vexRT[Btn6U]){
		fourBar_Forward(127);
		}
		else if(vexRT[Btn6D]){
		fourBar_Forward(-127);
		}
		else{
		fourBar_Forward(0);
		}*/

		if(vexRT[Btn5D]){
		mogo_Out(-127);
		}
		else if(vexRT[Btn5U]){
		mogo_Out(127);
		}
		else{
		mogo_Out(0);
		}
		if(vexRT[Btn8R]) {   //Claw stuffs
			fourBar_Backwards(127);
			} else if(vexRT[Btn8D]) {
			fourBar_Forward(127);
		}
		else{
			fourBar_Backwards(0);

		}
		if(vexRt[Btn8L]){
			startTask(pidController);
		}
		else{
			stopTask(pidController);
		}/*
		if(vexRT[Btn8DXmtr2]){//Claw stuffs
		mogo_Out(127);
		} else if(vexRT[Btn8RXmtr2]) {
		mogo_In(127);
		}
		*/


		motor[drive_Left]  = -(abs(vexRT[Ch2])> drivethreshhold)?((vexRT[Ch2]>drivelimit)?drivelimit:((vexRT[Ch2]<(-drivelimit))?-drivelimit:vexRT[Ch2])):0;  //Driving Stuffs I need to figure out (is that a ternary inside of a ternary?)
		motor[drive_Right]  = (abs(vexRT[Ch3])> drivethreshhold)?((vexRT[Ch3]>drivelimit)?drivelimit:((vexRT[Ch3]<(-drivelimit))?-drivelimit:vexRT[Ch3])):0;/*

		motor[lift_Left]=motor[lift_Right]  = -(abs(vexRT[Ch2])> drivethreshhold)?((vexRT[Ch2]>drivelimit)?drivelimit:((vexRT[Ch2]<(-drivelimit))?-drivelimit:vexRT[Ch2])):0;  //Driving Stuffs I need to figure out (is that a ternary inside of a ternary?)
		motor[fourBar_Left] = motor[fourBar_Right] =- (abs(vexRT[Ch3])> drivethreshhold)?((vexRT[Ch3]>drivelimit)?drivelimit:((vexRT[Ch3]<(-drivelimit))?-drivelimit:vexRT[Ch3])):0;

*/
	}
}
