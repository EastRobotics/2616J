#pragma config(Sensor, in1,    Left_Arm,       sensorPotentiometer)
#pragma config(Sensor, in2,    Right_Arm,      sensorPotentiometer)
#pragma config(Sensor, in3,    FouBar,         sensorPotentiometer)
#pragma config(Sensor, dgtl9,  drive_LeftSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, drive_RightSensor, sensorQuadEncoder)
#pragma config(Motor,  port2,           drive_Right,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift_Left,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           fourBar_Left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           fourBar_Right, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift_Right,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           drive_Left,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//!!Code automatically generated by 'ROBOTC' configuration wizard               !!//

//---------------------------------------------------------------------------//
/*                                                                           /
/        Description: Competition template for VEX EDR                      /
/                                                                           /
/---------------------------------------------------------------------------*/
// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define drivethreshhold 25
double drivelimit = 127;
int Program;
int deltaStuff;

//static float  pidRequestedValue;
//---------------------------------------------------------------------------//
/*                          Pre-Autonomous Functions                         /
/                                                                           /
/  You may want to perform some actions before the competition starts.      /
/  Do them in the following function.  You must return from this function   /
/  or the autonomous and usercontrol tasks will not be started.  This       /
/  function is only called once after the cortex has been powered on and    /
/  not every time that the robot is disabled.                               /
/---------------------------------------------------------------------------/



/-----------------------------------------------------------------------------/
/                                                                             /
/  main task                                                                  /
/                                                                             /
/-----------------------------------------------------------------------------*/
int countx = 0; //counter for function at line 199
void stack (int coneNumber){

}

void drive_Forward(int power) {
	motor[drive_Left]= power;
	motor[drive_Right] =power;
}

void turn_Left(int power) {
	motor[drive_Left]= power;
	motor[drive_Right] =-power;
}

void turn_Right(int power) {
	motor[drive_Left]= -power;
	motor[drive_Right] = power;
}

void drive_Backward(int power) {
	motor[drive_Left]= -power;
	motor[drive_Right] =-power;
}

void arm_Up (int power) {
	motor[lift_Left] =-power;
	motor[lift_Right] =-power;
}

void arm_Down (int power) {
	motor[lift_Left] =power;
	motor[lift_Right] =power;
}

void claw_Open (int power) {
	motor[claw] =power;
}

void claw_Close (int power) {
	motor[claw] =-power;
}

void mogo_In (int power) {
	motor[mogo] =-power;
}

void mogo_Out (int power) {
	motor[mogo] =power;
}

void fourBar_Forward (int power) {
	motor[fourBar_Left] =power;
	motor[fourBar_Right] = power;
}

void fourBar_Backwards (int power) {
	motor[fourBar_Left] =-power;
	motor[fourBar_Right] = -power;
}

int degrees=0;
task auton_DriveForward(){
	//deltaStuff = degrees - SensorValue[drive_RightSensor]
SensorValue[drive_RightSensor]=0
	while (SensorValue[drive_RightSensor] <=degrees){

		drive_Forward(127);
	}
	drive_Forward(0);

}

void auton_MogoOut(int degrees){
	while (SensorValue [mogo] < degrees){		//Need to check the encoddr value
		mogo_Out(127);
	}
	mogo_Out(0);
	SensorValue[mogo] = 0;
}

void auton_MogoIn( int degrees){
	while (SensorValue [mogo] > -degrees){		//Need to check the encoder value
		mogo_In(127);
	}
	mogo_In(0);
	SensorValue[mogo] = 0;
}
void auton_TurnRight( int rotations){
	while (SensorValue [drive_Right] < rotations){
		turn_Right(127); // Test this, it may be the other way around
	}
	turn_Right(0);
	SensorValue[drive_RightSensor] = 0;
}
void auton_TurnLeft( int rotations){
	while (SensorValue [drive_RightSensor] > rotations){
		turn_Left(127); // Test this, it may be the other way around (it is, same with lift)
	}
	turn_Left(0);
	SensorValue[drive_RightSensor] = 0;
}
void auton_DriveBackwards(int degrees){
	SensorValue[drive_RightSensor] =0;
	// grab current encoder value
	// subtract current and save to current
	while (SensorValue[drive_RightSensor] >= -degrees){ // use adjusted value
		drive_Backward(127);
	}
	drive_Backward(0);
}
void resetSensors(){
	SensorValue[drive_Left] = 0;
	SensorValue[drive_Right] = 0;

}/*
task noTipPlease()
{
while(SensorValue[Left_Arm] > 20){
drivelimit = 90;

}
}/*
task pidController()
{
float  pidSensorCurrentValue;
float  pidError;
float  pidArm;

while( true )
{
double pid_Kp=0.5;
// Read the sensor value and scale
pidSensorCurrentValue = SensorValue[FouBar];

// calculate error
pidError =  31 - pidSensorCurrentValue;
pidArm = (pid_Kp * pidError);

// limit drive
if( pidArm > 127 )
pidArm = 127;
if( pidArm < (-127) )
pidArm = (-127);

// send to motor
motor[fourBar_Left] = motor[fourBar_Right] = pidArm;

// Don't hog cpu
wait1Msec( 25 );
}
}*/
void stack_ArmUp (int rotations){
while (SensorValue [lift_Left] < rotations){
arm_Up(127); // Test this, it may be the other way around (it is, same with lift)
}
arm_Up(0);
SensorValue[lift_Left] = 0;

}

void testFunction(){
// if this function is called the lift raises according to a value in an array.
//everytime the button is pressed a counter variable is incremented
// the counter variable will index the array to determine certain height raised
/*
int heights[15];
heights[1] = 0;
heights[2] =20;
heights[3] =30;
heights[4] =40;
heights[5] =50;
heights[6] = 60;
heights[7] = 70;
heights[8] = 80;
heights[9] = 90;
heights[10] = 100;
heights[11] =110;
heights[12] = 120;
heights[13] = 130;*/
//figure out the predetermined heights
int heights[15];
double x;
int y;
heights[countx] = ((countx)*(x)) +y
while(SensorValue[Lift_Left] <heights[countx]){
arm_Up(127);
}
arm_Up(0);
 //resets the lift back down
countx++;//Not sure if this is what you want but I got down the basic logic
}
int leftButton = 1;
int centerButton = 2;
int rightButton = 4;

int homePage = 1; // The page to go to when we hit the 'home' button
int currentPage = homePage; // Can be whatever page you want within your set
int minPage = 1; // Should be the first page number in your set
int maxPage = 7; // Should be the last page number in your set
bool cycles = true; // Make pages a continuous loop (loops to start when at the end)

// Data vars (Millis to 1milli accuracy)
long lastRefresh = 0.0; // Last time we've refreshed in millis
long refreshTime = 200.0; // How many millis to wait before refreshing. Increments of 100ms minimum.
long holdStarted = 0.0; // Last time we've started a hold in millis
long lastHoldTime = -1.0; // How long we held a button last time we did.
// NOTE:
//	When interacting with lastHoldtime value in a page update, make sure to check that userInteraction
//	 -> is true, meaning a user caused the action. You know a user caused it when a button pressed.
//   -> You shouldn't use button hold times anywhere else, because the value will not always be recent.

// Example page vars
int menuMode = 1; //menu page
int menuMin = 1; //menu minimum page
int menuMax = 7; //menu maximum page

int linePosition = 0; //slider position
int linePosMin = 0; //slider minimum position
int linePosMax = 13; //slider maximum position

// Clears an entire LCD (Vex, y u no have)
void clearLCD() {
	clearLCDLine(0);
	clearLCDLine(1);
}

// Clears the pages and redraws
// NOTE:
// 	I find it's useful to get a piece of graph paper to figure out the page layout.
//   -> You can sketch out a 16x2 box and get a better idea of your limits
// PARAMETERS:
//	bool: Wether or not a user caused this update
void lcdUpdatePage( bool userInteraction )
{
	clearLCD();

	// Pages are defined under here. Messy, but it works.

	// Page 1 [The first page]
	if (currentPage == 1) {
    displayLCDCenteredString(0,"10 Right");
	}

	// Page 2 [The second page]
	else if (currentPage == 2) {
		displayLCDCenteredString(0,"10 Left");
	}

  //Page 3 [Menu page]
  else if(currentPage == 3) {
    displayLCDCenteredString(0,"20 Left");
   // switch(menuMode) {
     // case 1 :
       // displayLCDCenteredString(1,"< Menu opt. 1 >");
        //break;
      //case 2 :
        //displayLCDCenteredString(1,"< Menu opt. 2 >");
        //break;
      //case 3 :
        //displayLCDCenteredString(1,"< Menu opt. 3 >");
        //break;
      //default :
        ///displayLCDCenteredString(1,"! Menu opt. unknwn")

    }


	//Page 4 [Slider example/test]
	else if (currentPage == 4) {
		displayLCDCenteredString(0,"20 Right");
	}

	else if (currentPage == 5) {
		displayLCDCenteredString(0,"Worst inhibitions");
		displayLCDCenteredString(1, "Right");
	}

	else if (currentPage == 6) {
		displayLCDCenteredString(0,"Worst inhibitions");
		displayLCDCenteredString(1, "Left");
	}

	else if (currentPage == 7) {
		displayLCDCenteredString(0,"Gandalf");
	}


	// And pages carry on... make sure to increment maxPage for your page count!
}

// Returns the lcd to it's first page and redraws
// Triggered by middle button
void lcdHome()
{
	currentPage = homePage;
	lcdUpdatePage(true);
}

void lcdSetPage(int page) {
	// TODO Checks and stuff
	currentPage = page;
}

// Handles a request to go to the next page.
//  -> If there is one, it goes to it
//  -> If there isn't one and cycle is enable, it goes to first page
// Triggered by right button
void lcdNextPage()
{
	if (currentPage < maxPage) { // Theres another page to go to
		currentPage += 1;
		} else if (cycles) { // Go to the start of the loop if we cycle
		currentPage = minPage;
	}
	lcdUpdatePage(true);
}

// Handles a request to go to the previous page.
//  -> If there is one, it goes to it
//  -> If there isn't one and cycle is enable, it goes to last page
// Triggered by left button
void lcdLastPage()
{
	if (currentPage > minPage) { // Theres another page to go back to
		currentPage -= 1;
		} else if (cycles) { // Go to the end of the loop if we cycle
		currentPage = maxPage;
	}
	lcdUpdatePage(true);
}

// - lcdNext() and lcdBack() are called when an in-page action is clicked, for example
//   using for right or left on a menu.
// - lcdNext() is fired by middle+right, and lcdBack() is fired by middle+left.
// - This is not required for every page, only those wanting to handle these actions.
// - You should NOT be making changes to the lcd here. You should be updating a variable then
//   calling lcdUpdatePage(), where the variable is then handled.

// View above
void lcdBack() {
	// Page 1 [The first page]
	if (currentPage == 1) {
		lcdUpdatePage(true);
	}

	// Page 2 [The second page]
	else if (currentPage == 2) {
		lcdUpdatePage(true);
	}

	// Page 3 [Menu page]
	else if (currentPage == 3) {
    if (menuMode < menuMax) {
			menuMode += 1;
			} else {
			menuMode = menuMin;
		}
		lcdUpdatePage(true);
	}

	//Page 4 [Slider example/test]
	else if (currentPage == 4) {
  	if (linePosition < linePosMax) {
    	linePosition += 1;
    	lcdUpdatePage(true);
  	}
	}
}

// View above
void lcdNext() {
	// Page 1 [The first page]
	if (currentPage == 1) {
		lcdUpdatePage(true);
	}

	// Page 2 [The second page]
	else if (currentPage == 2) {
		lcdUpdatePage(true);
	}

	// Page 3 [Menu page]
	else if (currentPage == 3) {
    if (menuMode > menuMin) {
			menuMode -= 1;
		} else {
			menuMode = menuMax;
		}
		lcdUpdatePage(true);
	}

	//Page 4 [Slider example/test]
	else if (currentPage == 4) {
  	if (linePosition > linePosMin) {
    	linePosition -= 1;
    	lcdUpdatePage(true);
  	}
	}

}

// Reset the last time we've refreshed to the current time
void lcdResetAutoRefresh() {
	lastRefresh = time1[T4];
}

// Task to update the page if we have had no activity in refreshTime milliseconds
task lcdAutoRefreshTask() {
	lastHoldTime = -1.0;
	lcdUpdatePage(false); // Insure a page is already drawn
	while (true)
	{
		wait1Msec(10); // You only need to change this with a refresh rate lower than 10ms
		// If it's been refreshTime since last update
		if (time1[T4] - lastRefresh >= refreshTime) {
			lastHoldTime = -1.0;
			lcdUpdatePage(false);
			lcdResetAutoRefresh();
		}
	}
}

// Starts tracking the time of the press
void lcdStartHold() {
	holdStarted = time1[T4];
}

// Calculates how long it's been since we've started holding a button
// NOTE:
//	When interacting with lastHoldtime value in a page update, make sure to check that userInteraction
//	 -> is true, meaning a user caused the action. You know a user caused it when a button pressed.
//   -> You shouldn't use button hold times anywhere else, because the value will not always be recent.
//  *You should never call this function* unless making a custom button integration
//   -> Use the variable lastHoldTime in your action handling/page updating
// RETURNS:
//	long: How long the button was held for
long lcdEndHold() {
	lastHoldTime = time1[T4] - holdStarted;
	return lastHoldTime;
}

// This is where all of the default button handles are done, however you can use lcdNext
//  -> and other methods anywhere. For example, from buttons on the controller.
// This implementation is really great for making sure we read the correct button presses,
//  -> because we're reading so fast and not every release happens perfectly.
task lcdButtonTask() {
	bool buttonReleased = true;
	int highestCombination = 0;
	while (true) {
		if (nLCDButtons == 0) { // A button wasn't pressed
			if (buttonReleased == false) { // Button was pressed then released. Let's handle presses
				lcdEndHold(); // Update our last held count
				if (highestCombination == 1) { // Left button pressed
					lcdLastPage();
					buttonReleased = false;
				}
				else
					if (highestCombination == 2) { // Center button pressed
					lcdHome();
					buttonReleased = false;
				}
				else
					if (highestCombination == 4) { // Right button pressed
					lcdNextPage();
					buttonReleased = false;
				}
				else
					if (highestCombination == 3) { // Left & center pressed
					lcdNext();
				}
				else
					if (highestCombination == 6) { // Right & center pressed
					lcdBack();
				}
				buttonReleased = true;
				highestCombination = 0;
			} // Else: Nothing was pressed yet
		}
		else // A button was pressed but we haven't released
		{
			lcdResetAutoRefresh(); // Reset our countdown for resfreshing
			if (buttonReleased) { // If this is our first button pressed
				buttonReleased = false; // Tell us we have a button pushed down
				lcdStartHold(); // Start a button hold down
			}

			if (nLCDButtons > highestCombination) {
				highestCombination = nLCDButtons;
			}
		}
	}

}
// Sets everything up how it should be.
void lcdInit() {
	bLCDBacklight = true; // Turn our backlight on
	clearTimer(T4); // Reset our timer
	//startTask( lcdAutoRefreshTask ); // Initialize autorefreshing
	//startTask( lcdButtonTask ); // Initialize button checking
}
void pre_auton()
{
	while(bIfiRobotDisabled ==1){
	lcdInit();
	lcdUpdatePage(true);
	if(nLCDButtons==leftButton){
		lcdLastPage();
		lcdUpdatePage(true);
		}
	if(nLCDButtons==rightButton){
		lcdNextPage();
		lcdUpdatePage(true);
	}
}
	bStopTasksBetweenModes = true;
}
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...


//---------------------------------------------------------------------------//
/*                                                                           /
/                              Autonomous Task                              /
/                                                                           /
/  This task is used to control your robot during the autonomous phase of   /
/  a VEX Competition.                                                       /
/                                                                           /
/  You must modify the code to add your own robot specific commands here.   /
/---------------------------------------------------------------------------*/

task autonomous()
{

switch(currentPage){
case(1):
resetSensors();
	claw_Close(30);
	arm_Up(127);
	mogo_Out(-127);
	fourBar_Forward(127);
	wait10Msec(15);
	fourBar_Forward(0);
	wait10Msec(10);
	arm_Up(0);
	wait10Msec(100);
	mogo_Out(0);
	degrees=1150
	startTask(auton_DriveForward);
	resetSensors();
	mogo_In(-127);
	wait10Msec(120);
	arm_Down(127);
	wait10Msec(35);
	mogo_In(0);
	arm_Down(0);
	claw_Close(-127);
	wait10Msec(80);
	claw_Close(0);
	degrees =120;
	startTask(auton_DriveForward);
	resetSensors();

	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(50;
	claw_Close(30);
	arm_Up(127);
	wait10Msec(20);
	arm_Up(0);
	fourBar_Backwards(127);
	wait10Msec(85);
	fourBar_Backwards(0);
	claw_Close(-127);
	arm_Down(127);
	wait10Msec(40);
	arm_Down(0);
	degrees =90;
	startTask(auton_DriveForward);
	resetSensors();
	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(80);
	claw_Close(30);
	arm_Up(127);
	wait10Msec(25);
	arm_Up(0);

  fourBar_Backwards(127);
	wait10Msec(20);
	arm_Down(0);
	wait10Msec(65);
	fourBar_Backwards(0);
	claw_Close(-127);
	arm_Down(127);
	wait10Msec(40);
	arm_Down(0);
 degrees=90;
	startTask(auton_DriveForward);
	resetSensors();

	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(80);
	claw_Close(30);
	arm_Up(127);
	wait10Msec(25);
	arm_Up(0);

  fourBar_Backwards(127);
	wait10Msec(20);
	arm_Down(0);
	wait10Msec(65);
	fourBar_Backwards(0);
	claw_Close(-127);
	auton_DriveBackwards(1200);
	resetSensors();
	auton_TurnLeft(380);
	resetSensors();
	degrees=180;
	startTask(auton_DriveForward);
	resetSensors();
	mogo_Out(-127);
	wait10Msec(150);
	mogo_Out(0);
	auton_DriveBackwards(360);
	resetSensors();/*
break;
	case(2):
	claw_Close(30);
	arm_Up(127);
	mogo_Out(127);
	fourBar_Forward(127);
	wait10Msec(15);
	fourBar_Forward(0);
	wait10Msec(10);
	arm_Up(0);
	wait10Msec(100);
	mogo_Out(0);
	auton_DriveForward(1920);
	resetSensors();
	mogo_In(127);
	wait10Msec(120);
	arm_Down(127);
	wait10Msec(25);
	mogo_In(0);
	arm_Down(0);
	claw_Close(-127);
	wait10Msec(80);
	claw_Close(0);

	auton_DriveForward(90);
	resetSensors();
	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(50;
	claw_Close(30);
	fourBar_Backwards(127);
	wait10Msec(85);
	fourBar_Backwards(0);
	claw_Close(-127);

	auton_DriveForward(90);
	resetSensors();
	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(80);
	claw_Close(30);
	arm_Up(127);
	wait10Msec(15);
	arm_Up(0);
	arm_Down(127);
  fourBar_Backwards(127);
	wait10Msec(20);
	arm_Down(0);
	wait10Msec(65);
	fourBar_Backwards(0);
	claw_Close(-127);


	resetSensors();
	auton_DriveBackwards(2751);
	resetSensors();
	auton_TurnRight(1150);
	resetSensors();
	auton_DriveForward(180);
	resetSensors();
	mogo_Out(127);
	wait10Msec(150);
	mogo_Out(0);
	auton_DriveBackwards(360);
	resetSensors();
break;
	case(1):
	claw_Close(30);
	arm_Up(127);


	mogo_Out(-127);
	fourBar_Forward(127);
	wait10Msec(15);
	fourBar_Forward(0);
	wait10Msec(10);
	arm_Up(0);
	wait10Msec(100);
	mogo_Out(0);
	auton_DriveForward(1173);
	resetSensors();
	mogo_In(-127);
	wait10Msec(120);
	arm_Down(127);
	wait10Msec(35);
	mogo_In(0);
	arm_Down(0);
	claw_Close(-127);
	wait10Msec(80);
	claw_Close(0);
	auton_DriveForward(120);
	resetSensors();

	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(50;
	claw_Close(30);
	arm_Up(127);
	wait10Msec(20);
	arm_Up(0);
	fourBar_Backwards(127);
	wait10Msec(85);
	fourBar_Backwards(0);
	claw_Close(-127);
	arm_Down(127);
	wait10Msec(40);
	arm_Down(0);
	auton_DriveBackwards(1125);
	resetSensors();
	auton_TurnRight(180);
	resetSensors();
	auton_DriveForward(150);
	resetSensors();
	auton_TurnRight(180);
	resetSensors();
	auton_DriveForward(150);
	resetSensors();
	mogo_Out(-127);
	wait10Msec(150);
	mogo_Out(0);
	auton_DriveBackwards(500);
	resetSensors();
	break;


	case(4):
	claw_Close(30);
	arm_Up(127);
	mogo_Out(127);
	fourBar_Forward(127);
	wait10Msec(15);
	fourBar_Forward(0);
	wait10Msec(10);
	arm_Up(0);
	wait10Msec(100);
	mogo_Out(0);
	auton_DriveForward(1920);
	resetSensors();
	mogo_In(127);
	wait10Msec(120);
	arm_Down(127);
	wait10Msec(25);
	mogo_In(0);
	arm_Down(0);
	claw_Close(-127);
	wait10Msec(80);
	claw_Close(0);
	auton_DriveForward(90);
	resetSensors();
	resetSensors();
	fourBar_Forward(127);
	claw_Close(40);
	wait10Msec(80);
	fourBar_Forward(0);
	claw_Close(127);
	wait10Msec(80);
	claw_Close(30);
	fourBar_Backwards(127);
	wait10Msec(85);
	fourBar_Backwards(0);
	claw_Close(-127);
	auton_DriveBackwards(2751);
	resetSensors();
	auton_TurnLeft(575);
	resetSensors();
	auton_DriveForward(344);
	resetSensors();
	auton_TurnLeft(575);
	resetSensors();
	auton_DriveForward(429);
	resetSensors();
	mogo_Out(127);
	wait10Msec(150);
	mogo_Out(0);
	auton_DriveBackwards(900);
	resetSensors();
	break;

	case(7):
	drive_Forward(127);
	wait10Msec(950);
	drive_Forward(0);
	break;
*/
	default:
	//Dont have the Psych code done yet so........................................................
	break;
}
}
//}
// ..........................................................................
// Insert user code here.
// ..........................................................................

// Remove this function call once you have "real" code.


//---------------------------------------------------------------------------//
/*                                                                           /
/                              User Control Task                            /
/                                                                           /
/  This task is used to control your robot during the user control phase of /
/  a VEX Competition.                                                       /
/                                                                           /
/  You must modify the code to add your own robot specific commands here.   /
/---------------------------------------------------------------------------*/

task usercontrol()
{
	//startTask(noTipPlease);
	while(true) {
		if(vexRT[Btn6D]) {   //Claw stuffs
			arm_Down(-127);
			} else if(vexRT[Btn6U]) {
			arm_Up(-127);
		}
		else{
			arm_Down(0);
		}if(vexRT[Btn7R]){
		testFunction();

	}
	/*
		if(vexRT[Btn6DXmtr2]){
		mogo_In(127);
		}
		else if(vexRT[Btn6UXmtr2]){
		mogo_Out(127);
		}
		else{
		mogo_In(0);
		}*/

		if(vexRT[Btn7L]){
			claw_close(127);
		}
		else if(vexRT[Btn7D]){
			claw_Close(-127);
		}
		else{
			claw_Close(20);
		}

		/*
		if(vexRT[Btn6U]){
		fourBar_Forward(127);
		}
		else if(vexRT[Btn6D]){
		fourBar_Forward(-127);
		}
		else{
		fourBar_Forward(0);
		}*/

		if(vexRT[Btn5D]){
			mogo_Out(-127);
		}
		else if(vexRT[Btn5U]){
			mogo_Out(127);
		}
		else{
			mogo_Out(0);
		}
		if(vexRT[Btn8R]) {   //Claw stuffs
			fourBar_Backwards(127);
			} else if(vexRT[Btn8D]) {
			fourBar_Forward(127);
		}
		else{
			fourBar_Backwards(-10);

		}/*
		if(vexRt[Btn8L]){
		startTask(pidController);
		}
		else{
		stopTask(pidController);
		}/*
		if(vexRT[Btn8DXmtr2]){//Claw stuffs
		mogo_Out(127);
		} else if(vexRT[Btn8RXmtr2]) {
		mogo_In(127);
		}
		*/


		motor[drive_Left]  = -(abs(vexRT[Ch2])> drivethreshhold)?((vexRT[Ch2]>drivelimit)?drivelimit:((vexRT[Ch2]<(-drivelimit))?-drivelimit:vexRT[Ch2])):0;  //Driving Stuffs I need to figure out (is that a ternary inside of a ternary?)
		motor[drive_Right]  = (abs(vexRT[Ch3])> drivethreshhold)?((vexRT[Ch3]>drivelimit)?drivelimit:((vexRT[Ch3]<(-drivelimit))?-drivelimit:vexRT[Ch3])):0;/*

		motor[lift_Left]=motor[lift_Right]  = -(abs(vexRT[Ch2])> drivethreshhold)?((vexRT[Ch2]>drivelimit)?drivelimit:((vexRT[Ch2]<(-drivelimit))?-drivelimit:vexRT[Ch2])):0;  //Driving Stuffs I need to figure out (is that a ternary inside of a ternary?)
		motor[fourBar_Left] = motor[fourBar_Right] =- (abs(vexRT[Ch3])> drivethreshhold)?((vexRT[Ch3]>drivelimit)?drivelimit:((vexRT[Ch3]<(-drivelimit))?-drivelimit:vexRT[Ch3])):0;

		*/
	}

}
